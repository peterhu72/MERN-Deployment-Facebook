{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar DEFAULT_FILES_TO_IGNORE = ['.DS_Store', // OSX indexing file\n'Thumbs.db' // Windows indexing file\n]; // map of common (mostly media types) mime types to use when the browser does not supply the mime type\n\nvar EXTENSION_TO_MIME_TYPE_MAP = {\n  avi: 'video/avi',\n  gif: 'image/gif',\n  ico: 'image/x-icon',\n  jpeg: 'image/jpeg',\n  jpg: 'image/jpeg',\n  mkv: 'video/x-matroska',\n  mov: 'video/quicktime',\n  mp4: 'video/mp4',\n  pdf: 'application/pdf',\n  png: 'image/png',\n  zip: 'application/zip'\n};\n\nfunction shouldIgnoreFile(file) {\n  return DEFAULT_FILES_TO_IGNORE.indexOf(file.name) >= 0;\n}\n\nfunction copyString(aString) {\n  return (' ' + aString).slice(1);\n}\n\nfunction traverseDirectory(entry) {\n  var reader = entry.createReader(); // Resolved when the entire directory is traversed\n\n  return new Promise(function (resolveDirectory) {\n    var iterationAttempts = [];\n\n    var errorHandler = function errorHandler() {};\n\n    function readEntries() {\n      // According to the FileSystem API spec, readEntries() must be called until\n      // it calls the callback with an empty array.\n      reader.readEntries(function (batchEntries) {\n        if (!batchEntries.length) {\n          // Done iterating this particular directory\n          resolveDirectory(Promise.all(iterationAttempts));\n        } else {\n          // Add a list of promises for each directory entry.  If the entry is itself\n          // a directory, then that promise won't resolve until it is fully traversed.\n          iterationAttempts.push(Promise.all(batchEntries.map(function (batchEntry) {\n            if (batchEntry.isDirectory) {\n              return traverseDirectory(batchEntry);\n            }\n\n            return Promise.resolve(batchEntry);\n          }))); // Try calling readEntries() again for the same dir, according to spec\n\n          readEntries();\n        }\n      }, errorHandler);\n    } // initial call to recursive entry reader function\n\n\n    readEntries();\n  });\n} // package the file in an object that includes the fullPath from the file entry\n// that would otherwise be lost\n\n\nfunction packageFile(file, entry) {\n  var fileTypeOverride = ''; // handle some browsers sometimes missing mime types for dropped files\n\n  var hasExtension = file.name && file.name.lastIndexOf('.') !== -1;\n\n  if (hasExtension && !file.type) {\n    var fileExtension = (file.name || '').split('.').pop();\n    fileTypeOverride = EXTENSION_TO_MIME_TYPE_MAP[fileExtension];\n  }\n\n  return {\n    fileObject: file,\n    // provide access to the raw File object (required for uploading)\n    fullPath: entry ? copyString(entry.fullPath) : file.name,\n    lastModified: file.lastModified,\n    lastModifiedDate: file.lastModifiedDate,\n    name: file.name,\n    size: file.size,\n    type: file.type ? file.type : fileTypeOverride,\n    webkitRelativePath: file.webkitRelativePath\n  };\n}\n\nfunction getFile(entry) {\n  return new Promise(function (resolve) {\n    entry.file(function (file) {\n      resolve(packageFile(file, entry));\n    });\n  });\n}\n\nfunction handleFilePromises(promises, fileList) {\n  return Promise.all(promises).then(function (files) {\n    files.forEach(function (file) {\n      if (!shouldIgnoreFile(file)) {\n        fileList.push(file);\n      }\n    });\n    return fileList;\n  });\n}\n\nfunction getDataTransferFiles(dataTransfer) {\n  var dataTransferFiles = [];\n  var folderPromises = [];\n  var filePromises = [];\n  [].slice.call(dataTransfer.items).forEach(function (listItem) {\n    if (typeof listItem.webkitGetAsEntry === 'function') {\n      var entry = listItem.webkitGetAsEntry();\n\n      if (entry) {\n        if (entry.isDirectory) {\n          folderPromises.push(traverseDirectory(entry));\n        } else {\n          filePromises.push(getFile(entry));\n        }\n      }\n    } else {\n      dataTransferFiles.push(listItem);\n    }\n  });\n\n  if (folderPromises.length) {\n    var flatten = function flatten(array) {\n      return array.reduce(function (a, b) {\n        return a.concat(Array.isArray(b) ? flatten(b) : b);\n      }, []);\n    };\n\n    return Promise.all(folderPromises).then(function (fileEntries) {\n      var flattenedEntries = flatten(fileEntries); // collect async promises to convert each fileEntry into a File object\n\n      flattenedEntries.forEach(function (fileEntry) {\n        filePromises.push(getFile(fileEntry));\n      });\n      return handleFilePromises(filePromises, dataTransferFiles);\n    });\n  } else if (filePromises.length) {\n    return handleFilePromises(filePromises, dataTransferFiles);\n  }\n\n  return Promise.resolve(dataTransferFiles);\n}\n/**\n * This function should be called from both the onDrop event from your drag/drop\n * dropzone as well as from the HTML5 file selector input field onChange event\n * handler.  Pass the event object from the triggered event into this function.\n * Supports mix of files and folders dropped via drag/drop.\n *\n * Returns: an array of File objects, that includes all files within folders\n *   and subfolders of the dropped/selected items.\n */\n\n\nfunction getDroppedOrSelectedFiles(event) {\n  var dataTransfer = event.dataTransfer;\n\n  if (dataTransfer && dataTransfer.items) {\n    return getDataTransferFiles(dataTransfer).then(function (fileList) {\n      return Promise.resolve(fileList);\n    });\n  }\n\n  var files = [];\n  var dragDropFileList = dataTransfer && dataTransfer.files;\n  var inputFieldFileList = event.target && event.target.files;\n  var fileList = dragDropFileList || inputFieldFileList || []; // convert the FileList to a simple array of File objects\n\n  for (var i = 0; i < fileList.length; i++) {\n    files.push(packageFile(fileList[i]));\n  }\n\n  return Promise.resolve(files);\n}\n/**\n * Html5 File Selector\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\n\nexports.getDataTransferFiles = getDataTransferFiles;\nexports.getDroppedOrSelectedFiles = getDroppedOrSelectedFiles;","map":{"version":3,"mappings":"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","names":["DEFAULT_FILES_TO_IGNORE","EXTENSION_TO_MIME_TYPE_MAP","shouldIgnoreFile","file","indexOf","name","copyString","aString","slice","traverseDirectory","entry","reader","createReader","Promise","resolveDirectory","iterationAttempts","errorHandler","readEntries","batchEntries","length","all","push","map","batchEntry","isDirectory","resolve","packageFile","fileTypeOverride","hasExtension","lastIndexOf","type","fileExtension","split","pop","fullPath","lastModified","lastModifiedDate","size","webkitRelativePath","getFile","handleFilePromises","promises","fileList","then","files","forEach","getDataTransferFiles","dataTransfer","dataTransferFiles","folderPromises","filePromises","call","items","listItem","webkitGetAsEntry","flatten","array","reduce","a","b","concat","Array","isArray","fileEntries","flattenedEntries","fileEntry","getDroppedOrSelectedFiles","event","dragDropFileList","inputFieldFileList","target","i"],"sources":["/Users/peterhu/Desktop/Facebook/client/node_modules/src/Html5FileSelector.js","/Users/peterhu/Desktop/Facebook/client/node_modules/src/index.js"],"sourcesContent":["const DEFAULT_FILES_TO_IGNORE = [\n  '.DS_Store', // OSX indexing file\n  'Thumbs.db'  // Windows indexing file\n];\n\n// map of common (mostly media types) mime types to use when the browser does not supply the mime type\nconst EXTENSION_TO_MIME_TYPE_MAP = {\n  avi: 'video/avi',\n  gif: 'image/gif',\n  ico: 'image/x-icon',\n  jpeg: 'image/jpeg',\n  jpg: 'image/jpeg',\n  mkv: 'video/x-matroska',\n  mov: 'video/quicktime',\n  mp4: 'video/mp4',\n  pdf: 'application/pdf',\n  png: 'image/png',\n  zip: 'application/zip'\n};\n\nfunction shouldIgnoreFile(file) {\n  return DEFAULT_FILES_TO_IGNORE.indexOf(file.name) >= 0;\n}\n\nfunction copyString(aString) {\n  return ` ${aString}`.slice(1);\n}\n\nfunction traverseDirectory(entry) {\n  const reader = entry.createReader();\n  // Resolved when the entire directory is traversed\n  return new Promise((resolveDirectory) => {\n    const iterationAttempts = [];\n    const errorHandler = () => {};\n    function readEntries() {\n      // According to the FileSystem API spec, readEntries() must be called until\n      // it calls the callback with an empty array.\n      reader.readEntries((batchEntries) => {\n        if (!batchEntries.length) {\n          // Done iterating this particular directory\n          resolveDirectory(Promise.all(iterationAttempts));\n        } else {\n          // Add a list of promises for each directory entry.  If the entry is itself\n          // a directory, then that promise won't resolve until it is fully traversed.\n          iterationAttempts.push(Promise.all(batchEntries.map((batchEntry) => {\n            if (batchEntry.isDirectory) {\n              return traverseDirectory(batchEntry);\n            }\n            return Promise.resolve(batchEntry);\n          })));\n          // Try calling readEntries() again for the same dir, according to spec\n          readEntries();\n        }\n      }, errorHandler);\n    }\n    // initial call to recursive entry reader function\n    readEntries();\n  });\n}\n\n// package the file in an object that includes the fullPath from the file entry\n// that would otherwise be lost\nfunction packageFile(file, entry) {\n  let fileTypeOverride = '';\n  // handle some browsers sometimes missing mime types for dropped files\n  const hasExtension = file.name && file.name.lastIndexOf('.') !== -1;\n  if (hasExtension && !file.type) {\n    const fileExtension = (file.name || '').split('.').pop();\n    fileTypeOverride = EXTENSION_TO_MIME_TYPE_MAP[fileExtension];\n  }\n  return {\n    fileObject: file, // provide access to the raw File object (required for uploading)\n    fullPath: entry ? copyString(entry.fullPath) : file.name,\n    lastModified: file.lastModified,\n    lastModifiedDate: file.lastModifiedDate,\n    name: file.name,\n    size: file.size,\n    type: file.type ? file.type : fileTypeOverride,\n    webkitRelativePath: file.webkitRelativePath\n  };\n}\n\nfunction getFile(entry) {\n  return new Promise((resolve) => {\n    entry.file((file) => {\n      resolve(packageFile(file, entry));\n    });\n  });\n}\n\nfunction handleFilePromises(promises, fileList) {\n  return Promise.all(promises).then((files) => {\n    files.forEach((file) => {\n      if (!shouldIgnoreFile(file)) {\n        fileList.push(file);\n      }\n    });\n    return fileList;\n  });\n}\n\nexport function getDataTransferFiles(dataTransfer) {\n  const dataTransferFiles = [];\n  const folderPromises = [];\n  const filePromises = [];\n\n  [].slice.call(dataTransfer.items).forEach((listItem) => {\n    if (typeof listItem.webkitGetAsEntry === 'function') {\n      const entry = listItem.webkitGetAsEntry();\n\n      if (entry) {\n        if (entry.isDirectory) {\n          folderPromises.push(traverseDirectory(entry));\n        } else {\n          filePromises.push(getFile(entry));\n        }\n      }\n    } else {\n      dataTransferFiles.push(listItem);\n    }\n  });\n  if (folderPromises.length) {\n    const flatten = (array) => array.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);\n    return Promise.all(folderPromises).then((fileEntries) => {\n      const flattenedEntries = flatten(fileEntries);\n      // collect async promises to convert each fileEntry into a File object\n      flattenedEntries.forEach((fileEntry) => {\n        filePromises.push(getFile(fileEntry));\n      });\n      return handleFilePromises(filePromises, dataTransferFiles);\n    });\n  } else if (filePromises.length) {\n    return handleFilePromises(filePromises, dataTransferFiles);\n  }\n  return Promise.resolve(dataTransferFiles);\n}\n\n/**\n * This function should be called from both the onDrop event from your drag/drop\n * dropzone as well as from the HTML5 file selector input field onChange event\n * handler.  Pass the event object from the triggered event into this function.\n * Supports mix of files and folders dropped via drag/drop.\n *\n * Returns: an array of File objects, that includes all files within folders\n *   and subfolders of the dropped/selected items.\n */\nexport function getDroppedOrSelectedFiles(event) {\n  const dataTransfer = event.dataTransfer;\n  if (dataTransfer && dataTransfer.items) {\n    return getDataTransferFiles(dataTransfer).then((fileList) => {\n      return Promise.resolve(fileList);\n    });\n  }\n  const files = [];\n  const dragDropFileList = dataTransfer && dataTransfer.files;\n  const inputFieldFileList = event.target && event.target.files;\n  const fileList = dragDropFileList || inputFieldFileList || [];\n  // convert the FileList to a simple array of File objects\n  for (let i = 0; i < fileList.length; i++) {\n    files.push(packageFile(fileList[i]));\n  }\n  return Promise.resolve(files);\n}\n","/**\n * Html5 File Selector\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.txt file in the root directory of this source tree.\n */\n\nexport { getDataTransferFiles, getDroppedOrSelectedFiles } from './Html5FileSelector.js';\n"]},"metadata":{},"sourceType":"script"}